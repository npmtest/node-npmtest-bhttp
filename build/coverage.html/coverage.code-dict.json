{"/home/travis/build/npmtest/node-npmtest-bhttp/test.js":"/* istanbul instrument in package npmtest_bhttp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-bhttp/lib.npmtest_bhttp.js":"/* istanbul instrument in package npmtest_bhttp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_bhttp = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_bhttp = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-bhttp/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-bhttp && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_bhttp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_bhttp\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_bhttp.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_bhttp.rollup.js'] =\n            local.assetsDict['/assets.npmtest_bhttp.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_bhttp.__dirname + '/lib.npmtest_bhttp.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-bhttp/node_modules/bhttp/index.js":"module.exports = require(\"./lib/bhttp\");\n","/home/travis/build/npmtest/node-npmtest-bhttp/node_modules/bhttp/lib/bhttp.js":"// Generated by CoffeeScript 1.9.3\nvar Promise, S, _, addErrorData, bhttpAPI, bhttpErrors, concatStream, createCookieJar, debug, debugRequest, debugResponse, devNull, doPayloadRequest, doRedirect, errors, extend, formData, formFixArray, http, https, isStream, makeRequest, ofTypes, packageConfig, prepareCleanup, prepareDefaults, prepareOptions, preparePayload, prepareProtocol, prepareRequest, prepareSession, prepareUrl, processResponse, querystring, redirectGet, redirectUnchanged, sink, spy, stream, streamLength, toughCookie, urlUtil, util;\n\nurlUtil = require(\"url\");\n\nquerystring = require(\"querystring\");\n\nstream = require(\"stream\");\n\nhttp = require(\"http\");\n\nhttps = require(\"https\");\n\nutil = require(\"util\");\n\nPromise = require(\"bluebird\");\n\n_ = require(\"lodash\");\n\nS = require(\"string\");\n\nformFixArray = require(\"form-fix-array\");\n\nerrors = require(\"errors\");\n\ndebug = require(\"debug\");\n\ndebugRequest = debug(\"bhttp:request\");\n\ndebugResponse = debug(\"bhttp:response\");\n\nextend = require(\"extend\");\n\ndevNull = require(\"dev-null\");\n\nformData = require(\"form-data2\");\n\nconcatStream = require(\"concat-stream\");\n\ntoughCookie = require(\"tough-cookie\");\n\nstreamLength = require(\"stream-length\");\n\nsink = require(\"through2-sink\");\n\nspy = require(\"through2-spy\");\n\npackageConfig = require(\"../package.json\");\n\nbhttpErrors = {};\n\nerrors.create({\n  name: \"bhttpError\",\n  scope: bhttpErrors\n});\n\nerrors.create({\n  name: \"ConflictingOptionsError\",\n  parents: bhttpErrors.bhttpError,\n  scope: bhttpErrors\n});\n\nerrors.create({\n  name: \"UnsupportedProtocolError\",\n  parents: bhttpErrors.bhttpError,\n  scope: bhttpErrors\n});\n\nerrors.create({\n  name: \"RedirectError\",\n  parents: bhttpErrors.bhttpError,\n  scope: bhttpErrors\n});\n\nerrors.create({\n  name: \"MultipartError\",\n  parents: bhttpErrors.bhttpError,\n  scope: bhttpErrors\n});\n\nerrors.create({\n  name: \"ConnectionTimeoutError\",\n  parents: bhttpErrors.bhttpError,\n  scope: bhttpErrors\n});\n\nerrors.create({\n  name: \"ResponseTimeoutError\",\n  parents: bhttpErrors.bhttpError,\n  scope: bhttpErrors\n});\n\nofTypes = function(obj, types) {\n  var i, len, match, type;\n  match = false;\n  for (i = 0, len = types.length; i < len; i++) {\n    type = types[i];\n    match = match || obj instanceof type;\n  }\n  return match;\n};\n\naddErrorData = function(err, request, response, requestState) {\n  err.request = request;\n  err.response = response;\n  err.requestState = requestState;\n  return err;\n};\n\nisStream = function(obj) {\n  return (obj != null) && (ofTypes(obj, [stream.Readable, stream.Duplex, stream.Transform]) || obj.hasOwnProperty(\"_bhttpStreamWrapper\"));\n};\n\nprepareSession = function(request, response, requestState) {\n  debugRequest(\"preparing session\");\n  return Promise[\"try\"](function() {\n    if (requestState.sessionOptions != null) {\n      request.options = _.merge(_.clone(requestState.sessionOptions), request.options);\n    }\n    if (request.options.headers != null) {\n      request.options.headers = _.clone(request.options.headers, true);\n    } else {\n      request.options.headers = {};\n    }\n    if (request.options.cookieJar != null) {\n      return Promise[\"try\"](function() {\n        request.cookieJar = request.options.cookieJar;\n        delete request.options.cookieJar;\n        return request.cookieJar.get(request.url);\n      }).then(function(cookieString) {\n        debugRequest(\"sending cookie string: %s\", cookieString);\n        request.options.headers[\"cookie\"] = cookieString;\n        return Promise.resolve([request, response, requestState]);\n      });\n    } else {\n      return Promise.resolve([request, response, requestState]);\n    }\n  });\n};\n\nprepareDefaults = function(request, response, requestState) {\n  debugRequest(\"preparing defaults\");\n  return Promise[\"try\"](function() {\n    var base, base1, base2, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7;\n    request.responseOptions = {\n      discardResponse: (ref = request.options.discardResponse) != null ? ref : false,\n      keepRedirectResponses: (ref1 = request.options.keepRedirectResponses) != null ? ref1 : false,\n      followRedirects: (ref2 = request.options.followRedirects) != null ? ref2 : true,\n      noDecode: (ref3 = request.options.noDecode) != null ? ref3 : false,\n      decodeJSON: (ref4 = request.options.decodeJSON) != null ? ref4 : false,\n      stream: (ref5 = request.options.stream) != null ? ref5 : false,\n      justPrepare: (ref6 = request.options.justPrepare) != null ? ref6 : false,\n      redirectLimit: (ref7 = request.options.redirectLimit) != null ? ref7 : 10,\n      onDownloadProgress: request.options.onDownloadProgress,\n      responseTimeout: request.options.responseTimeout\n    };\n    if ((base = request.options).allowChunkedMultipart == null) {\n      base.allowChunkedMultipart = false;\n    }\n    if ((base1 = request.options).forceMultipart == null) {\n      base1.forceMultipart = false;\n    }\n    if ((base2 = request.options.headers)[\"user-agent\"] == null) {\n      base2[\"user-agent\"] = \"bhttp/\" + packageConfig.version;\n    }\n    request.options.method = request.options.method.toLowerCase();\n    return Promise.resolve([request, response, requestState]);\n  });\n};\n\nprepareUrl = function(request, response, requestState) {\n  debugRequest(\"preparing URL\");\n  return Promise[\"try\"](function() {\n    var ref, urlOptions;\n    urlOptions = urlUtil.parse(request.url, true);\n    _.extend(request.options, {\n      hostname: urlOptions.hostname,\n      port: urlOptions.port\n    });\n    request.options.path = urlUtil.format({\n      pathname: urlOptions.pathname,\n      query: (ref = request.options.query) != null ? ref : urlOptions.query\n    });\n    request.protocol = S(urlOptions.protocol).chompRight(\":\").toString();\n    return Promise.resolve([request, response, requestState]);\n  });\n};\n\nprepareProtocol = function(request, response, requestState) {\n  debugRequest(\"preparing protocol\");\n  return Promise[\"try\"](function() {\n    var base;\n    request.protocolModule = (function() {\n      switch (request.protocol) {\n        case \"http\":\n          return http;\n        case \"https\":\n          return https;\n        default:\n          return null;\n      }\n    })();\n    if (request.protocolModule == null) {\n      return Promise.reject()(new bhttpErrors.UnsupportedProtocolError(\"The protocol specified (\" + protocol + \") is not currently supported by this module.\"));\n    }\n    if ((base = request.options).port == null) {\n      base.port = (function() {\n        switch (request.protocol) {\n          case \"http\":\n            return 80;\n          case \"https\":\n            return 443;\n        }\n      })();\n    }\n    return Promise.resolve([request, response, requestState]);\n  });\n};\n\nprepareOptions = function(request, response, requestState) {\n  debugRequest(\"preparing options\");\n  return Promise[\"try\"](function() {\n    var base;\n    if (((request.options.formFields != null) || (request.options.files != null)) && ((request.options.inputStream != null) || (request.options.inputBuffer != null))) {\n      return Promise.reject(addErrorData(new bhttpErrors.ConflictingOptionsError(\"You cannot define both formFields/files and a raw inputStream or inputBuffer.\"), request, response, requestState));\n    }\n    if (request.options.encodeJSON && ((request.options.inputStream != null) || (request.options.inputBuffer != null))) {\n      return Promise.reject(addErrorData(new bhttpErrors.ConflictingOptionsError(\"You cannot use both encodeJSON and a raw inputStream or inputBuffer.\", void 0, \"If you meant to JSON-encode the stream, you will currently have to do so manually.\"), request, response, requestState));\n    }\n    if (request.responseOptions.stream) {\n      if ((base = request.options).agent == null) {\n        base.agent = false;\n      }\n    }\n    return Promise.resolve([request, response, requestState]);\n  });\n};\n\npreparePayload = function(request, response, requestState) {\n  debugRequest(\"preparing payload\");\n  return Promise[\"try\"](function() {\n    var containsStreams, fieldName, fieldValue, formDataObject, i, len, multipart, ref, ref1, ref2, streamOptions, valueElement;\n    request.onUploadProgress = request.options.onUploadProgress;\n    multipart = request.options.forceMultipart || (request.options.files != null);\n    multipart = multipart || _.any(request.options.formFields, function(item) {\n      return item instanceof Buffer || isStream(item);\n    });\n    _.extend(request.options.formFields, request.options.files);\n    containsStreams = _.any(request.options.formFields, function(item) {\n      return isStream(item);\n    });\n    if (request.options.encodeJSON && containsStreams) {\n      return Promise.reject()(new bhttpErrors.ConflictingOptionsError(\"Sending a JSON-encoded payload containing data from a stream is not currently supported.\", void 0, \"Either don't use encodeJSON, or read your stream into a string or Buffer.\"));\n    }\n    if ((ref = request.options.method) !== \"get\" && ref !== \"head\" && ref !== \"delete\") {\n      if ((request.options.encodeJSON || (request.options.formFields != null)) && !multipart) {\n        debugRequest(\"got url-encodable form-data\");\n        if (request.options.encodeJSON) {\n          debugRequest(\"... but encodeJSON was set, so we will send JSON instead\");\n          request.options.headers[\"content-type\"] = \"application/json\";\n          request.payload = JSON.stringify((ref1 = request.options.formFields) != null ? ref1 : null);\n        } else if (!_.isEmpty(request.options.formFields)) {\n          request.options.headers[\"content-type\"] = \"application/x-www-form-urlencoded\";\n          request.payload = querystring.stringify(formFixArray(request.options.formFields));\n        } else {\n          request.payload = \"\";\n        }\n        request.options.headers[\"content-length\"] = request.payload.length;\n        return Promise.resolve();\n      } else if ((request.options.formFields != null) && multipart) {\n        debugRequest(\"got multipart form-data\");\n        formDataObject = new formData();\n        ref2 = formFixArray(request.options.formFields);\n        for (fieldName in ref2) {\n          fieldValue = ref2[fieldName];\n          if (!_.isArray(fieldValue)) {\n            fieldValue = [fieldValue];\n          }\n          for (i = 0, len = fieldValue.length; i < len; i++) {\n            valueElement = fieldValue[i];\n            if (valueElement._bhttpStreamWrapper != null) {\n              streamOptions = valueElement.options;\n              valueElement = valueElement.stream;\n            } else {\n              streamOptions = {};\n            }\n            formDataObject.append(fieldName, valueElement, streamOptions);\n          }\n        }\n        request.payloadStream = formDataObject;\n        return Promise[\"try\"](function() {\n          return formDataObject.getHeaders();\n        }).then(function(headers) {\n          if (headers[\"content-transfer-encoding\"] === \"chunked\" && !request.options.allowChunkedMultipart) {\n            return Promise.reject(addErrorData(new MultipartError(\"Most servers do not support chunked transfer encoding for multipart/form-data payloads, and we could not determine the length of all the input streams. See the documentation for more information.\"), request, response, requestState));\n          } else {\n            _.extend(request.options.headers, headers);\n            return Promise.resolve();\n          }\n        });\n      } else if (request.options.inputStream != null) {\n        debugRequest(\"got inputStream\");\n        return Promise[\"try\"](function() {\n          var ref3;\n          request.payloadStream = request.options.inputStream;\n          if ((request.payloadStream._bhttpStreamWrapper != null) && ((request.payloadStream.options.contentLength != null) || (request.payloadStream.options.knownLength != null))) {\n            return Promise.resolve((ref3 = request.payloadStream.options.contentLength) != null ? ref3 : request.payloadStream.options.knownLength);\n          } else {\n            return streamLength(request.options.inputStream);\n          }\n        }).then(function(length) {\n          debugRequest(\"length for inputStream is %s\", length);\n          return request.options.headers[\"content-length\"] = length;\n        })[\"catch\"](function(err) {\n          debugRequest(\"unable to determine inputStream length, switching to chunked transfer encoding\");\n          return request.options.headers[\"content-transfer-encoding\"] = \"chunked\";\n        });\n      } else if (request.options.inputBuffer != null) {\n        debugRequest(\"got inputBuffer\");\n        if (typeof request.options.inputBuffer === \"string\") {\n          request.payload = new Buffer(request.options.inputBuffer);\n        } else {\n          request.payload = request.options.inputBuffer;\n        }\n        debugRequest(\"length for inputBuffer is %s\", request.payload.length);\n        request.options.headers[\"content-length\"] = request.payload.length;\n        return Promise.resolve();\n      } else {\n        return Promise.resolve();\n      }\n    } else {\n      return Promise.resolve();\n    }\n  }).then(function() {\n    return Promise.resolve([request, response, requestState]);\n  });\n};\n\nprepareCleanup = function(request, response, requestState) {\n  debugRequest(\"preparing cleanup\");\n  return Promise[\"try\"](function() {\n    var fixedHeaders, i, key, len, ref, ref1, value;\n    ref = [\"query\", \"formFields\", \"files\", \"encodeJSON\", \"inputStream\", \"inputBuffer\", \"discardResponse\", \"keepRedirectResponses\", \"followRedirects\", \"noDecode\", \"decodeJSON\", \"allowChunkedMultipart\", \"forceMultipart\", \"onUploadProgress\", \"onDownloadProgress\"];\n    for (i = 0, len = ref.length; i < len; i++) {\n      key = ref[i];\n      delete request.options[key];\n    }\n    fixedHeaders = {};\n    ref1 = request.options.headers;\n    for (key in ref1) {\n      value = ref1[key];\n      fixedHeaders[key.toLowerCase()] = value;\n    }\n    request.options.headers = fixedHeaders;\n    return Promise.resolve([request, response, requestState]);\n  });\n};\n\nprepareRequest = function(request, response, requestState) {\n  debugRequest(\"preparing request\");\n  return Promise[\"try\"](function() {\n    var middlewareFunctions, promiseChain;\n    middlewareFunctions = [prepareSession, prepareDefaults, prepareUrl, prepareProtocol, prepareOptions, preparePayload, prepareCleanup];\n    promiseChain = Promise.resolve([request, response, requestState]);\n    middlewareFunctions.forEach(function(middleware) {\n      return promiseChain = promiseChain.spread(function(_request, _response, _requestState) {\n        return middleware(_request, _response, _requestState);\n      });\n    });\n    return promiseChain;\n  });\n};\n\nmakeRequest = function(request, response, requestState) {\n  debugRequest(\"making %s request to %s\", request.options.method.toUpperCase(), request.url);\n  return Promise[\"try\"](function() {\n    var req, timeoutTimer;\n    req = request.protocolModule.request(request.options);\n    timeoutTimer = null;\n    return new Promise(function(resolve, reject) {\n      var completedBytes, progressStream, totalBytes;\n      if (request.responseOptions.responseTimeout != null) {\n        debugRequest(\"setting response timeout timer to \" + request.responseOptions.responseTimeout + \"ms...\");\n        req.on(\"socket\", function(socket) {\n          var timeoutHandler;\n          timeoutHandler = function() {\n            debugRequest(\"a response timeout occurred!\");\n            req.abort();\n            return reject(addErrorData(new bhttpErrors.ResponseTimeoutError(\"The response timed out.\")));\n          };\n          return timeoutTimer = setTimeout(timeoutHandler, request.responseOptions.responseTimeout);\n        });\n      }\n      totalBytes = request.options.headers[\"content-length\"];\n      completedBytes = 0;\n      progressStream = spy(function(chunk) {\n        completedBytes += chunk.length;\n        return req.emit(\"progress\", completedBytes, totalBytes);\n      });\n      if (request.onUploadProgress != null) {\n        req.on(\"progress\", function(completedBytes, totalBytes) {\n          return request.onUploadProgress(completedBytes, totalBytes, req);\n        });\n      }\n      if (request.payload != null) {\n        debugRequest(\"sending payload\");\n        req.emit(\"progress\", request.payload.length, request.payload.length);\n        req.write(request.payload);\n        req.end();\n      } else if (request.payloadStream != null) {\n        debugRequest(\"piping payloadStream\");\n        if (request.payloadStream._bhttpStreamWrapper != null) {\n          request.payloadStream.stream.pipe(progressStream).pipe(req);\n        } else {\n          request.payloadStream.pipe(progressStream).pipe(req);\n        }\n      } else {\n        debugRequest(\"closing request without payload\");\n        req.end();\n      }\n      req.on(\"error\", function(err) {\n        if (err.code === \"ETIMEDOUT\") {\n          debugRequest(\"a connection timeout occurred!\");\n          return reject(addErrorData(new bhttpErrors.ConnectionTimeoutError(\"The connection timed out.\")));\n        } else {\n          return reject(err);\n        }\n      });\n      return req.on(\"response\", function(res) {\n        if (timeoutTimer != null) {\n          debugResponse(\"got response in time, clearing response timeout timer\");\n          clearTimeout(timeoutTimer);\n        }\n        return resolve(res);\n      });\n    });\n  }).then(function(response) {\n    return Promise.resolve([request, response, requestState]);\n  });\n};\n\nprocessResponse = function(request, response, requestState) {\n  debugResponse(\"processing response, got status code %s\", response.statusCode);\n  return Promise[\"try\"](function() {\n    var cookieHeader, promises;\n    if ((request.cookieJar != null) && (response.headers[\"set-cookie\"] != null)) {\n      promises = (function() {\n        var i, len, ref, results;\n        ref = response.headers[\"set-cookie\"];\n        results = [];\n        for (i = 0, len = ref.length; i < len; i++) {\n          cookieHeader = ref[i];\n          debugResponse(\"storing cookie: %s\", cookieHeader);\n          results.push(request.cookieJar.set(cookieHeader, request.url));\n        }\n        return results;\n      })();\n      return Promise.all(promises);\n    } else {\n      return Promise.resolve();\n    }\n  }).then(function() {\n    var completedBytes, progressStream, ref, ref1, totalBytes;\n    response.request = request;\n    response.requestState = requestState;\n    response.redirectHistory = requestState.redirectHistory;\n    if (((ref = response.statusCode) === 301 || ref === 302 || ref === 303 || ref === 307) && request.responseOptions.followRedirects) {\n      if (requestState.redirectHistory.length >= (request.responseOptions.redirectLimit - 1)) {\n        return Promise.reject(addErrorData(new bhttpErrors.RedirectError(\"The maximum amount of redirects ({request.responseOptions.redirectLimit}) was reached.\")));\n      }\n      switch (response.statusCode) {\n        case 301:\n          switch (request.options.method) {\n            case \"get\":\n            case \"head\":\n              return redirectUnchanged(request, response, requestState);\n            case \"post\":\n            case \"put\":\n            case \"patch\":\n            case \"delete\":\n              return Promise.reject(addErrorData(new bhttpErrors.RedirectError(\"Encountered a 301 redirect for POST, PUT, PATCH or DELETE. RFC says we can't automatically continue.\"), request, response, requestState));\n            default:\n              return Promise.reject(addErrorData(new bhttpErrors.RedirectError(\"Encountered a 301 redirect, but not sure how to proceed for the \" + (request.options.method.toUpperCase()) + \" method.\")));\n          }\n          break;\n        case 302:\n        case 303:\n          return redirectGet(request, response, requestState);\n        case 307:\n          if (request.containsStreams && ((ref1 = request.options.method) !== \"get\" && ref1 !== \"head\")) {\n            return Promise.reject(addErrorData(new bhttpErrors.RedirectError(\"Encountered a 307 redirect for POST, PUT or DELETE, but your payload contained (single-use) streams. We therefore can't automatically follow the redirect.\"), request, response, requestState));\n          } else {\n            return redirectUnchanged(request, response, requestState);\n          }\n      }\n    } else if (request.responseOptions.discardResponse) {\n      response.pipe(devNull());\n      return Promise.resolve(response);\n    } else {\n      totalBytes = response.headers[\"content-length\"];\n      if (totalBytes != null) {\n        totalBytes = parseInt(totalBytes);\n      }\n      completedBytes = 0;\n      progressStream = sink(function(chunk) {\n        completedBytes += chunk.length;\n        return response.emit(\"progress\", completedBytes, totalBytes);\n      });\n      if (request.responseOptions.onDownloadProgress != null) {\n        response.on(\"progress\", function(completedBytes, totalBytes) {\n          return request.responseOptions.onDownloadProgress(completedBytes, totalBytes, response);\n        });\n      }\n      return new Promise(function(resolve, reject) {\n        var _on, _progressStreamAttached, _resume, attachProgressStream;\n        _resume = response.resume.bind(response);\n        _on = response.on.bind(response);\n        _progressStreamAttached = false;\n        attachProgressStream = function() {\n          if (!_progressStreamAttached) {\n            debugResponse(\"attaching progress stream\");\n            _progressStreamAttached = true;\n            return response.pipe(progressStream);\n          }\n        };\n        response.on = function(eventName, handler) {\n          debugResponse(\"'on' called, \" + eventName);\n          if (eventName === \"data\" || eventName === \"readable\") {\n            attachProgressStream();\n          }\n          return _on(eventName, handler);\n        };\n        response.resume = function() {\n          attachProgressStream();\n          return _resume();\n        };\n        if (request.responseOptions.stream) {\n          return resolve(response);\n        } else {\n          response.on(\"error\", function(err) {\n            return reject(err);\n          });\n          return response.pipe(concatStream(function(body) {\n            var err, ref2;\n            if (request.responseOptions.decodeJSON || (((ref2 = response.headers[\"content-type\"]) != null ? ref2 : \"\").split(\";\")[0] === \"application/json\" && !request.responseOptions.noDecode)) {\n              try {\n                response.body = JSON.parse(body);\n              } catch (_error) {\n                err = _error;\n                reject(err);\n              }\n            } else {\n              response.body = body;\n            }\n            return resolve(response);\n          }));\n        }\n      });\n    }\n  }).then(function(response) {\n    return Promise.resolve([request, response, requestState]);\n  });\n};\n\ndoPayloadRequest = function(url, data, options, callback) {\n  if (isStream(data)) {\n    options.inputStream = data;\n  } else if (ofTypes(data, [Buffer]) || typeof data === \"string\") {\n    options.inputBuffer = data;\n  } else {\n    options.formFields = data;\n  }\n  return this.request(url, options, callback);\n};\n\nredirectGet = function(request, response, requestState) {\n  debugResponse(\"following forced-GET redirect to %s\", response.headers[\"location\"]);\n  return Promise[\"try\"](function() {\n    var i, key, len, options, ref;\n    options = _.clone(requestState.originalOptions);\n    options.method = \"get\";\n    ref = [\"inputBuffer\", \"inputStream\", \"files\", \"formFields\"];\n    for (i = 0, len = ref.length; i < len; i++) {\n      key = ref[i];\n      delete options[key];\n    }\n    return doRedirect(request, response, requestState, options);\n  });\n};\n\nredirectUnchanged = function(request, response, requestState) {\n  debugResponse(\"following same-method redirect to %s\", response.headers[\"location\"]);\n  return Promise[\"try\"](function() {\n    var options;\n    options = _.clone(requestState.originalOptions);\n    return doRedirect(request, response, requestState, options);\n  });\n};\n\ndoRedirect = function(request, response, requestState, newOptions) {\n  return Promise[\"try\"](function() {\n    if (!request.responseOptions.keepRedirectResponses) {\n      response.pipe(devNull());\n    }\n    requestState.redirectHistory.push(response);\n    return bhttpAPI._doRequest(urlUtil.resolve(request.url, response.headers[\"location\"]), newOptions, requestState);\n  });\n};\n\ncreateCookieJar = function(jar) {\n  return {\n    set: function(cookie, url) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.jar.setCookie(cookie, url, function(err, cookie) {\n            if (err) {\n              return reject(err);\n            } else {\n              return resolve(cookie);\n            }\n          });\n        };\n      })(this));\n    },\n    get: function(url) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.jar.getCookieString(url, function(err, cookies) {\n            if (err) {\n              return reject(err);\n            } else {\n              return resolve(cookies);\n            }\n          });\n        };\n      })(this));\n    },\n    jar: jar\n  };\n};\n\nbhttpAPI = {\n  head: function(url, options, callback) {\n    if (options == null) {\n      options = {};\n    }\n    options.method = \"head\";\n    return this.request(url, options, callback);\n  },\n  get: function(url, options, callback) {\n    if (options == null) {\n      options = {};\n    }\n    options.method = \"get\";\n    return this.request(url, options, callback);\n  },\n  post: function(url, data, options, callback) {\n    if (options == null) {\n      options = {};\n    }\n    options.method = \"post\";\n    return doPayloadRequest.bind(this)(url, data, options, callback);\n  },\n  put: function(url, data, options, callback) {\n    if (options == null) {\n      options = {};\n    }\n    options.method = \"put\";\n    return doPayloadRequest.bind(this)(url, data, options, callback);\n  },\n  patch: function(url, data, options, callback) {\n    if (options == null) {\n      options = {};\n    }\n    options.method = \"patch\";\n    return doPayloadRequest.bind(this)(url, data, options, callback);\n  },\n  \"delete\": function(url, options, callback) {\n    if (options == null) {\n      options = {};\n    }\n    options.method = \"delete\";\n    return this.request(url, options, callback);\n  },\n  request: function(url, options, callback) {\n    if (options == null) {\n      options = {};\n    }\n    return this._doRequest(url, options).nodeify(callback);\n  },\n  _doRequest: function(url, options, requestState) {\n    return Promise[\"try\"]((function(_this) {\n      return function() {\n        var ref, request, response;\n        request = {\n          url: url,\n          options: _.clone(options)\n        };\n        response = null;\n        if (requestState == null) {\n          requestState = {\n            originalOptions: _.clone(options),\n            redirectHistory: []\n          };\n        }\n        if (requestState.sessionOptions == null) {\n          requestState.sessionOptions = (ref = _this._sessionOptions) != null ? ref : {};\n        }\n        return prepareRequest(request, response, requestState);\n      };\n    })(this)).spread((function(_this) {\n      return function(request, response, requestState) {\n        if (request.responseOptions.justPrepare) {\n          return Promise.resolve([request, response, requestState]);\n        } else {\n          return Promise[\"try\"](function() {\n            return bhttpAPI.executeRequest(request, response, requestState);\n          }).spread(function(request, response, requestState) {\n            return Promise.resolve(response);\n          });\n        }\n      };\n    })(this));\n  },\n  executeRequest: function(request, response, requestState) {\n    return Promise[\"try\"](function() {\n      return makeRequest(request, response, requestState);\n    }).spread(function(request, response, requestState) {\n      return processResponse(request, response, requestState);\n    });\n  },\n  session: function(options) {\n    var key, session, value;\n    if (options == null) {\n      options = {};\n    }\n    options = _.clone(options);\n    session = {};\n    for (key in this) {\n      value = this[key];\n      if (value instanceof Function) {\n        value = value.bind(session);\n      }\n      session[key] = value;\n    }\n    if (options.cookieJar == null) {\n      options.cookieJar = createCookieJar(new toughCookie.CookieJar());\n    } else if (options.cookieJar === false) {\n      delete options.cookieJar;\n    } else {\n      options.cookieJar = createCookieJar(options.cookieJar);\n    }\n    session._sessionOptions = options;\n    return session;\n  },\n  wrapStream: function(stream, options) {\n    return {\n      _bhttpStreamWrapper: true,\n      stream: stream,\n      options: options\n    };\n  }\n};\n\nextend(bhttpAPI, bhttpErrors);\n\nmodule.exports = bhttpAPI;\n","/home/travis/build/npmtest/node-npmtest-bhttp/node_modules/bhttp/gulpfile.js":"var gulp = require('gulp');\n\n/* CoffeeScript compile deps */\nvar path = require('path');\nvar gutil = require('gulp-util');\nvar concat = require('gulp-concat');\nvar rename = require('gulp-rename');\nvar coffee = require('gulp-coffee');\nvar cache = require('gulp-cached');\nvar remember = require('gulp-remember');\nvar plumber = require('gulp-plumber');\n\nvar source = [\"lib/**/*.coffee\", \"index.coffee\"]\n\ngulp.task('coffee', function() {\n\treturn gulp.src(source, {base: \".\"})\n\t\t.pipe(plumber())\n\t\t.pipe(cache(\"coffee\"))\n\t\t.pipe(coffee({bare: true}).on('error', gutil.log)).on('data', gutil.log)\n\t\t.pipe(remember(\"coffee\"))\n\t\t.pipe(gulp.dest(\".\"));\n});\n\ngulp.task('watch', function () {\n\tgulp.watch(source, ['coffee']);\n});\n\ngulp.task('default', ['coffee', 'watch']);","/home/travis/build/npmtest/node-npmtest-bhttp/node_modules/bhttp/testcase1.js":"var bhttp = require(\"./\");\nvar stockName = \"AAPL\";\nvar debug = require(\"debug\")(\"testcase1\");\nvar util = require(\"util\");\n\nbhttp.get('http://finance.yahoo.com/q/ks?s=' + stockName + '+Key+Statistics', { stream: false }, function(err, res) {\n\tif(err) {\n\t\tdebug('ERROR: ' + err)\n\t  return callback(err)\n\t} else {\n\t\tdebug('res: ' + util.inspect(res))\n\t}\n})\n"}